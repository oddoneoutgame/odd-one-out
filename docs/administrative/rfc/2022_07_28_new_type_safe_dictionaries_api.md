# Access strings through a new type-safe Dictionaries API

## Why?

There are a few things about our current dictionaries approach related to how we retrieve string values that can be
improved.

* We currently use string resources generated by the DictionaryResourceKeysGenerator. This causes dictionaries in
  Disney+ to contain strings that are not present in the Star+ or Hulu and vice versa, leading to having some string
  keys removed or missing and hence, confusion.

* We don't have a single entry point for obtaining a string which sometimes causes unexpected behaviour or errors in the
  app. We currently have `optionalString`, `string`, `withResourceKey().string()`
  or `withResourceKey().optionalString()`.

* It is error-prone since it allows us to request a string by passing a key in the form of a string with as many
  replacements as we want. Errors while performing this might not be easy to notice and changes across dictionaries can
  go unseen.

## What?

The main idea behind this solution is to create new type-safe API exposing a `Dictionaries` class that will provide
direct access to string values without having to pass keys as resourceIds or strings. This direct access will happen by
exposing either read-only variables or functions to request for the values of these keys, depending on whether the value
of that key requires runtime replacements or not. The functions will those replacements already as parameters in their
signature.

All of this, also gives us the possibility of referencing dictionary keys of different apps (D+/S+/Hulu) and
keys that are only available on a limited set of apps/platforms in a safe way.

Finally, with some lint checks and custom attributes, we could get rid of the generated string resources for dictionary
keys completely which gives us:

1. Less confusion
2. Faster Builds
3. Smaller APKs

These lint checks and attributes will allow us to reference strings directly from xml files safely by giving
error/warning/info highlights that will help developers to know:

1. When a string key - dictionary combination is non-existent giving the developer more info on which dictionary
   actually contains that string key (Error)
2. When a string key doesn't exist in any app dictionary (Error)
3. When something is missing (namespace declaration or some mandatory attribute) (Error)
4. When a key that is being referenced through xml contains replacements (Warning)

An example of how the usage of this solution would look like vs what we use to have could be:

* Before (without replacements)

```kotlin
return when {
    promoLabelState.isImaxAvailable -> detailPromoLabelItemFactory.create(
        stringDictionary.string(R.string.promo_imax_header),
        "..."
    )
}

// OR

return when {
    promoLabelState.isImaxAvailable -> detailPromoLabelItemFactory.create(
        withResourceKey("application").string("promo_imax_header"),
        "..."
    )
}
```

* After (without replacements)

```kotlin
return when {
    promoLabelState.isImaxAvailable -> detailPromoLabelItemFactory.create(
        dictionaries.application.promo_imax_header,
        "..."
    )
}
```

* Before (with replacements)

```kotlin
return when {
    promoLabelState.isImaxAvailable -> detailPromoLabelItemFactory.create(
        stringDictionary.string(
            R.string.promo_imax_header,
            mapOf("someReplacementKey" to "someReplacementValue")
        ),
        "..."
    )
}

// OR

return when {
    promoLabelState.isImaxAvailable -> detailPromoLabelItemFactory.create(
        withResourceKey("application").string(
            "promo_imax_header",
            mapOf("someReplacementKey" to "someReplacementValue")
        ),
        "..."
    )
}
```

* After (with replacements)

```kotlin
return when {
    promoLabelState.isImaxAvailable -> detailPromoLabelItemFactory.create(
        dictionaries.application.promo_imax_header(someReplacementKey = "someReplacementValue"),
        "..."
    )
}
```

## How?

The solution proposed to fix this issues consists in different parts:

1- Get rid of our current `DictionaryResourceKeysGenerator` hence also getting rid of all our `...dictionary_keys.xml`
files. Replace this for a new kotlin script in charge of retrieving and saving the dictionary entries for each one of
our dictionaries merging all the project and platforms into single files. For
example (`application_dictionary_entries.json`), an idea for this is:

```json
[
  {
    "metadata_series_detail": {
      "placeholders": [
        "time",
        "hours"
      ],
      "partners": [
        "disney",
        "star",
        "hulu"
      ],
      "platforms": [
        "android-tv",
        "android"
      ]
    },
    "btn_retry": {
      "...": "..."
    },
    "...": {
      "...": "..."
    }
  }
]
```

This way we will have a single source of truth of all the keys for a certain dictionary with their respective
replacements needed to form the actual string without any distinction between projects (hulu, disney, star) or device
(tv, mobile).

2- Introduce a new Dictionaries interface and AllDictionaries class which will hold instances of each one of our
dictionaries (application, sdk-errors, etc...). This dictionaries will have a `getString` method that will at the end
use our LazyDictionary instances to retrieve the values. For example:

```kotlin
interface Dictionaries {

    fun interface Dictionary {
        fun getString(key: String, replacements: Map<String, Any?>): String
    }

    val accessibility: AccessibilityDictionary
    val application: ApplicationDictionary
    // etc...

    fun interface AccessibilityDictionary : Dictionary
    fun interface ApplicationDictionary : Dictionary
    // etc...
}
```

```kotlin
class AllDictionaries @Inject constructor(
    private val dictionaryLoadingCheck: DictionaryLoadingCheck,
    private val stateProvider: DictionariesState.Provider,
    private val resources: Resources,
    private val sentryWrapper: SentryWrapper
) : Dictionaries {

    private val lazyAccessibility: LazyDictionaryV3 = createLazyDictionary("accessibility")
    private val lazyApplication: LazyDictionaryV3 = createLazyDictionary("application")
    // etc...  

    override val accessibility = Dictionaries.AccessibilityDictionary { key, replacements ->
        lazyAccessibility.string(key, replacements)
    }

    override val application = Dictionaries.ApplicationDictionary { key, replacements ->
        lazyApplication.string(key, replacements)
    }
    // etc...

    private fun createLazyDictionary(resourceKey: String) {
        return LazyDictionaryV3(
            stateProvider,
            dictionaryLoadingCheck,
            FallbackDictionary(resources),
            resourceKey,
            sentryWrapper,
            resources
        )
    }
}
```

3- Create a new gradle plugin+task that will read from our dictionaries json files and generate kotlin files containing
extension functions/val that will resolve into the actual strings. This will make the access to strings across the app
easier and intuitive. The return type will be a String for those keys that are present for every app, and optional for
those that appear in certain apps. For example, one of this generated files could look like:

```kotlin
val Dictionaries.ApplicationDictionary.account_change_password_header: String
    get() = getString("account_change_password_header", emptyMap())

val Dictionaries.ApplicationDictionary.account_create_password_title: String
    get() = getString("account_create_password_title", emptyMap())

/**
 * account_createpassword_title key is only present in: Hulu and Star
 */
val Dictionaries.ApplicationDictionary.account_createpassword_title: String?
    get() = getString("account_createpassword_title", emptyMap())

val Dictionaries.ApplicationDictionary.account_details: String
    get() = getString("account_details", emptyMap())

/**
 * account_disney_visa_rewards_offer key is only present in: Disney
 */
fun Dictionaries.ApplicationDictionary.account_disney_visa_rewards_offer(
    DATE: String,
    PRICE_DURATION: String,
): String? = getString(
    "account_disney_visa_rewards_offer", mapOf(
        "DATE" to DATE,
        "PRICE/DURATION" to PRICE_DURATION,
    )
)

val Dictionaries.ApplicationDictionary.account_email_placeholder: String
    get() = getString("account_email_placeholder", emptyMap())

fun Dictionaries.ApplicationDictionary.account_free_trial_duration(
    DATE: String,
) = getString(
    "account_free_trial_duration", mapOf(
        "DATE" to DATE,
    )
)
```

Using the kotlin `inline` modifier for the previous generated properties and function has 1 pros and a few neutral
considerations:

* Pros:
    * Since the compiler will get rid of these and replace their calls with the actual code on site, it will make it
      harder for outer people to sneak-peak newly introduced dictionary keys (preventing them to discover new features).
* Neutral:
    * There might be only a minimal runtime benefit on inlining these since we are not using lambdas.
    * Using inline functions and/or properties might make the final generated code to grow bigger. In our case since we
      don't repeat the usage of keys too much across our codebase, it shouldn't be an issue.
* Cons:
    * No actual big cons for our codebase.

To sum up this step of the `how`, a usage example of these auto-generated keys (If we take
the `DetailPromoLabelPresenter` `getPromoLabel` method return statement) would look like the following:

Without replacements:

```kotlin
return when {
    promoLabelTitle != null ->
        detailPromoLabelItemFactory.create(promoLabelTitle, promoMessage.promoLabelDisclaimer)
    promoLabelState.isImaxAvailable -> detailPromoLabelItemFactory.create(
        dictionaries.application.promo_imax_header,
        "..."
    )
    else -> null
}
```

With replacements:

```kotlin
return when {
    promoLabelTitle != null ->
        detailPromoLabelItemFactory.create(promoLabelTitle, promoMessage.promoLabelDisclaimer)
    promoLabelState.isImaxAvailable -> detailPromoLabelItemFactory.create(
        dictionaries.application.promo_imax_header("fake replacement", 2),
        "..."
    )
    else -> null
}
```

4- Currently we use a custom implementation of the BaseActivity LayoutInflaterWrapper in order to get the correct
dictionary values from the keys used in our xml layout files. This happens by getting the text attribute values (for
android:text, app:hint or app:queryHint for example) from different View types (TextView, SearchView, ImageView, etc...)
and using our current dictionary implementation to retrieve them. It looks like this:

```kotlin
private fun applyLayoutAttributes(
    context: Context,
    attrs: AttributeSet,
    view: View
) {
    when (view) {
        is AppCompatImageView -> applyImageViewAttributes(context, attrs, view)
        is SearchView -> context.withStyledAttributes(attrs, searchViewAttributes) {
            val dictionary = getDictionary(typedArray = this, index = 1)
            val resourceId = getResourceId(queryHintAttribute, defaultAttributeValue)
            if (resourceId != defaultAttributeValue) {
                view.queryHint = dictionary.string(resourceId)
            }
        }
        is StandardButton -> context.withStyledAttributes(attrs, standardButtonAttributes) {
            val dictionary = getDictionary(typedArray = this, index = 2)
            val textResourceId = getResourceId(0, defaultAttributeValue)
            if (textResourceId != defaultAttributeValue) {
                view.text = dictionary.string(textResourceId)
            }
            val contentDescriptionId = getResourceId(1, defaultAttributeValue)
            if (contentDescriptionId != defaultAttributeValue) {
                view.contentDescription = dictionary.string(contentDescriptionId)
            }
        }
        "..." -> {}
    }
}
```

In order to make our new approach to work with this, we need to:

* adapt our current `ConfigStringsLayoutInflater` and xml usage of strings by adding 2 new attributes to a
  new`dictionaries` namespace: `dictionary` and `dictionaryKey`, discouraging the use of the normal text attributes.
* Start consuming those attributes instead of the old ones within our `ConfigStringsLayoutInflater` to retrieve strings
  with the new `dictionaries` API.

This is how it would look like in a xml:

```xml
<?xml version="1.0" encoding="utf-8"?>
<TextView xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:dictionaries="http://schemas.android.com/apk/res/android"
          android:id="@+id/about_section_title"
          android:layout_width="match_parent"
          android:layout_height="40dp"
          android:gravity="start|center_vertical"
          dictionaries:dictionary="application"
          dictionaries:dictionaryKey="button_blabla"
          style="@style/TypeRamp.BodyCopy.Headline"/>
```

5- Add the Lint checks previously mentioned in the `What` section.

6- So far the `how` section has taking into account our current string placeholder implementation (That
being: `${someReplacement}`). Considering the fact that ICU will soon be released, we need to adapt all of this
approach to consider the ICU plural form and ICU placeholders instead of our legacy ones. That means that we will need
to start supporting icu placeholders: `{someReplacement}`, and plural forms:
`The film won {n, plural, =0 {no awards} one {# award} other {# awards}}`

7- Distribute the workload of migrating from the legacy way of retrieving strings to this new one across the feature
teams.

## Impact

This will impact all the parts of our app that are currently using our dictionaries. It's good to clarify that the
impact of this approach is low in the sense that it can coexist with our previous approach, not forcing developers to
make big breaking changes in a short period.

## More info/insights

A draft PR has already been created for this, feel free to check it out. It is not definitive nor final (it was barely a
first approach) but it can also give some more informative and clear view of the idea behind this proposal
