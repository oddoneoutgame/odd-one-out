# CODE GENERATION FOR VIEWMODELS

## Why?

It is fairly often that developers wonder why they can't use `@HiltViewModel` to annotate their ViewModels and avoid manually declaring their ViewModels in a dedicated Dagger Module, with the answer being that HiltViewModel only allows to inject such ViewModels in `@AndroidEntryPoint`'s, namely translating to Fragments and Activities.

However, seeing as the declaration of these ViewModels is fairly predictable and deterministic, I think we could leverage annotation processing and code generation ourselves, to create an annotation of our own that will automatically generate the Dagger module providing the instances of that ViewModel.

Doing this will not only liberate the developer from the creation of such boilerplate code, but also automatically reflect changes in the signature of that ViewModel's construction; currently if the constructor changes we have to amend both the ViewModel itself and the associated Module providing its instance; by allowing code generation to do that job for us this is done automatically.

## What?

I am proposing the creation of our custom @DmgzViewModel (open to changing the name) with a given scope, which is enough information for a code generation to infer and create a DaggerModule in the same package, with all necessary injected parameters.

In order to demonstrate the effect I have created a quick (and dirty) prototype in [this branch](https://github.bamtech.co/Android/Dmgz/tree/gs/code-generation-test).

## How?

With this solution, all of our ViewModels can be annotated with either `@DmgzViewModel(scope = ViewModelScope.ACTIVITY)` or `@DmgzViewModel(scope = ViewModelScope.FRAGMENT)` and the declaration of their provider method in the corresponding Dagger Module can be removed.

In the aforementioned [branch](https://github.bamtech.co/Android/Dmgz/tree/gs/code-generation-test) both a Fragment scoped ViewModel (see [here](https://github.bamtech.co/Android/Dmgz/blob/gs/code-generation-test/features/cast/src/main/java/com/bamtechmedia/dominguez/cast/audiosubtitles/AudioAndSubtitlesViewModel.kt)) and an Activity scoped ViewModel (seen [here](https://github.bamtech.co/Android/Dmgz/blob/gs/code-generation-test/features/cast/src/main/java/com/bamtechmedia/dominguez/cast/castcontroller/CastControllerViewModel.kt)) are getting their modules generated by this quick prototype.

## Impact

- If successful, this will impact all (or most) of our ViewModels and we can safely remove the declaring provider code in the Dagger Modules.

- If one particular scenario requires a different mechanism for ViewModel creation, this option is always available by having that ViewModel not being annotated.

- A working code generation solution reduces the chances of errors in declaring these bindings manually.

- Further changes to constructor signature are reflected automatically, reducing the load of such changes.

- If we would change the way our ViewModel store works in the future, or if we would be switching to Kotlin modules at some point, this can be done automatically by reflecting such changes in the code generator.

- This feature would open the door to the use of code generation, which potentially could be used for more improvements in our app or reduce boilerplate.

- As a downside, it can be argued that this hides logic, but this argument applies to many of the libraries we use, not the least of it being Dagger Hilt.
